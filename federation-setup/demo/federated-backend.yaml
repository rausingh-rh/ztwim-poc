---
apiVersion: v1
kind: Namespace
metadata:
  name: federation-demo
---
apiVersion: v1
kind: ServiceAccount
metadata:
  name: federated-backend
  namespace: federation-demo
---
apiVersion: spire.spiffe.io/v1alpha1
kind: ClusterSPIFFEID
metadata:
  name: federated-backend
spec:
  spiffeIDTemplate: "spiffe://apps.cluster-2.devcluster.openshift.com/ns/{{ .PodMeta.Namespace }}/sa/{{ .PodSpec.ServiceAccountName }}"
  podSelector:
    matchLabels:
      app: federated-backend
  namespaceSelector:
    matchLabels:
      kubernetes.io/metadata.name: federation-demo
  federatesWith:
  - "apps.cluster-1.devcluster.openshift.com"
  className: zero-trust-workload-identity-manager-spire
---
apiVersion: v1
kind: ConfigMap
metadata:
  name: federated-backend-app
  namespace: federation-demo
data:
  main.go: |
    package main

    import (
        "context"
        "fmt"
        "log"
        "net/http"
        "time"

        "github.com/spiffe/go-spiffe/v2/spiffeid"
        "github.com/spiffe/go-spiffe/v2/spiffetls/tlsconfig"
        "github.com/spiffe/go-spiffe/v2/workloadapi"
    )

    func main() {
        ctx, cancel := context.WithCancel(context.Background())
        defer cancel()

        socketPath := "unix:///spiffe-workload-api/spire-agent.sock"
        log.Printf("ğŸš€ Starting FEDERATED Backend Server (Cluster 2)")
        log.Printf("ğŸ“¡ Connecting to SPIFFE Workload API at: %s", socketPath)

        // Create X.509 source
        source, err := workloadapi.NewX509Source(ctx, workloadapi.WithClientOptions(workloadapi.WithAddr(socketPath)))
        if err != nil {
            log.Fatalf("âŒ Unable to create X509Source: %v", err)
        }
        defer source.Close()

        // Get SVID to display identity
        svid, err := source.GetX509SVID()
        if err != nil {
            log.Fatalf("âŒ Unable to get X509 SVID: %v", err)
        }
        log.Printf("âœ… My SPIFFE ID: %s", svid.ID)

        // Get bundle to see federated trust domains
        bundle, err := source.GetX509BundleForTrustDomain(spiffeid.RequireTrustDomainFromString("apps.cluster-2.devcluster.openshift.com"))
        if err != nil {
            log.Printf("âš ï¸  Could not get own bundle: %v", err)
        } else {
            log.Printf("âœ… Own trust bundle loaded: %d certificates", len(bundle.X509Authorities()))
        }

        // Check for federated bundle
        federatedBundle, err := source.GetX509BundleForTrustDomain(spiffeid.RequireTrustDomainFromString("apps.cluster-1.devcluster.openshift.com"))
        if err != nil {
            log.Printf("âŒ No federated bundle for cluster-1: %v", err)
        } else {
            log.Printf("âœ… FEDERATED trust bundle loaded: %d certificates from cluster-1", len(federatedBundle.X509Authorities()))
        }

        // Create HTTP handler
        http.HandleFunc("/", func(w http.ResponseWriter, r *http.Request) {
            log.Printf("ğŸ“¥ Received request from: %s", r.RemoteAddr)
            
            // Get client's SPIFFE ID from the peer certificate
            if r.TLS != nil && len(r.TLS.PeerCertificates) > 0 {
                clientID, err := spiffeid.FromURI(r.TLS.PeerCertificates[0].URIs[0])
                if err == nil {
                    log.Printf("âœ… Verified client SPIFFE ID: %s", clientID)
                    
                    response := fmt.Sprintf(`
â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘          FEDERATED BACKEND RESPONSE (Cluster 2)            â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

âœ… SUCCESS: mTLS Connection Established!

Backend SPIFFE ID:  %s
Client SPIFFE ID:   %s

ğŸ‰ FEDERATION IS WORKING!

Backend Trust Domains:
  â€¢ apps.cluster-2.devcluster.openshift.com (own)
  â€¢ apps.cluster-1.devcluster.openshift.com (federated)

This proves:
  âœ… Trust bundles are exchanged
  âœ… Cross-cluster mTLS works
  âœ… Federation is operational

Time: %s
`, svid.ID, clientID, time.Now().Format(time.RFC3339))

                    w.Header().Set("Content-Type", "text/plain")
                    w.WriteHeader(http.StatusOK)
                    w.Write([]byte(response))
                    log.Printf("âœ… Sent successful response to client")
                    return
                }
            }

            log.Printf("âŒ No valid client certificate")
            http.Error(w, "Unauthorized", http.StatusUnauthorized)
        })

        // Create TLS config with SPIFFE authentication
        tlsConfig := tlsconfig.MTLSServerConfig(source, source, tlsconfig.AuthorizeAny())
        server := &http.Server{
            Addr:      ":8443",
            TLSConfig: tlsConfig,
        }

        log.Printf("ğŸŒ Starting HTTPS server on :8443 with mTLS (SPIFFE federation enabled)")
        log.Printf("ğŸ” Accepting connections from:")
        log.Printf("   â€¢ apps.cluster-2.devcluster.openshift.com (own domain)")
        log.Printf("   â€¢ apps.cluster-1.devcluster.openshift.com (federated domain)")
        log.Printf("")
        log.Printf("Waiting for connections...")

        if err := server.ListenAndServeTLS("", ""); err != nil {
            log.Fatalf("âŒ Server failed: %v", err)
        }
    }
  go.mod: |
    module backend

    go 1.21

    require github.com/spiffe/go-spiffe/v2 v2.1.7

    require (
        github.com/Microsoft/go-winio v0.6.1 // indirect
        github.com/go-jose/go-jose/v3 v3.0.1 // indirect
        github.com/zeebo/errs v1.3.0 // indirect
        golang.org/x/crypto v0.17.0 // indirect
        golang.org/x/mod v0.8.0 // indirect
        golang.org/x/sys v0.15.0 // indirect
        golang.org/x/tools v0.6.0 // indirect
        google.golang.org/genproto/googleapis/rpc v0.0.0-20230822172742-b8732ec3820d // indirect
        google.golang.org/grpc v1.59.0 // indirect
        google.golang.org/protobuf v1.31.0 // indirect
    )
---
apiVersion: apps/v1
kind: Deployment
metadata:
  name: federated-backend
  namespace: federation-demo
spec:
  replicas: 1
  selector:
    matchLabels:
      app: federated-backend
  template:
    metadata:
      labels:
        app: federated-backend
    spec:
      serviceAccountName: federated-backend
      containers:
      - name: backend
        image: golang:1.21
        workingDir: /app
        command: ["/bin/bash", "-c"]
        args:
        - |
          cp /config/* /app/
          go mod download
          go run main.go
        ports:
        - containerPort: 8443
          name: https
        volumeMounts:
        - name: spiffe-workload-api
          mountPath: /spiffe-workload-api
          readOnly: true
        - name: config
          mountPath: /config
      volumes:
      - name: spiffe-workload-api
        csi:
          driver: csi.spiffe.io
          readOnly: true
      - name: config
        configMap:
          name: federated-backend-app
---
apiVersion: v1
kind: Service
metadata:
  name: federated-backend
  namespace: federation-demo
spec:
  selector:
    app: federated-backend
  ports:
  - port: 8443
    targetPort: 8443
    name: https
  type: ClusterIP

